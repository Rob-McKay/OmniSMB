

/* OmniClient front end for SMB */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>
#include <stdint.h>

#include <kernel.h>
#include <swis.h>

#include "Global/RISCOS.h"
#include "Global/Services.h"
#include "Global/OsBytes.h"
#include "OmniClient.h"

#include "AsmUtils/rminfo.h"

#include "DebugLib/DebugLib.h"

#include "omnismb.h"
#include "OmniSMBHdr.h"
#include "message_trans.h"

#define FILING_SYSTEM_NAME "SMB"

#define DO_PRINTING 0

/*******************************************************************/
/* Global variables */

void *modules_private_word;

extern int msg_struct[4];

static bool server_list_has_changed;
static bool registered_with_omniclient;

static osmb_active_server *server_list;
static osmb_active_mount *mount_list;

static volatile int tick_pending, datagram_pending, callback_pending;

static void server_item_check_name(osmb_active_server *as);

/*******************************************************************/

static _kernel_oserror *register_client(void)
{
    _kernel_swi_regs r;
    char titlebar[24];    /* Title bar - 24 max */
    char infobox[3 * 32]; /* Info box - 3x32 max */

    strcpy(titlebar, message_trans_lookup("_Version", NULL));
    sprintf(infobox, "%s\n"
                     "\xA9 Rob McKay, 2023\n"
                     "%s",
            message_trans_lookup("Whosmb", NULL), titlebar);
    strncpy(titlebar, message_trans_lookup("DispName", NULL), sizeof(titlebar));

    r.r[0] = OmniSMB_OmniOp; /* SWI number */
    r.r[1] = OmniRegisterFlag_NeedUser | OmniRegisterFlag_NeedPass |
             OmniRegisterFlag_NeedPath | OmniRegisterFlag_NeedAuth |
             /*OmniRegisterFlag_Printer |*/ OmniRegisterFlag_FilingSystem |
             ('/' << OmniRegisterFlag_ExtensionShift); /* Flags */
    r.r[2] = (int)"04a480";                            /* Sprite name - 12 max */
    r.r[3] = (int)titlebar;                            /* Title bar - 24 max */
    r.r[4] = (int)infobox;                             /* Info box - 3x32 max */

    r.r[5] = 0;                       /* Site ID (ignored) */
    r.r[6] = (int)FILING_SYSTEM_NAME; /* Filing system name */

    return _kernel_swi(Omni_RegisterClient, &r, &r);
}

static void deregister_client(void)
{
    _kernel_swi_regs r;

    r.r[0] = OmniSMB_OmniOp; /* SWI number */

    _kernel_swi(Omni_DeregisterClient, &r, &r);
}

static void setup_callback(void)
{
    if (callback_pending == 0)
    {
        _kernel_swi_regs r;

        r.r[0] = (int)&callback_entry;
        r.r[1] = (int)modules_private_word;
        callback_pending = 1;

        _kernel_swi(OS_AddCallBack, &r, &r);
    }
}

static void clear_callback(void)
{
    if (callback_pending)
    {
        _kernel_swi_regs r;

        r.r[0] = (int)&callback_entry;
        r.r[1] = (int)modules_private_word;

        callback_pending = 0;
        _kernel_swi(OS_RemoveCallBack, &r, &r);
    }
}

static _kernel_oserror *setup_ticker_and_event(void)
{
    _kernel_swi_regs r;
    _kernel_oserror *ep;

    r.r[0] = EventV;
    r.r[1] = (int)&inet_entry;
    r.r[2] = (int)modules_private_word;

    ep = _kernel_swi(XOS_Bit + OS_Claim, &r, &r);

    if (ep)
        return ep;

    _kernel_osbyte(OsByte_EnableEvent, Event_Internet, 0);

    r.r[0] = TICKER_RATE;
    r.r[1] = (int)timer_entry;
    r.r[2] = (int)modules_private_word;

    ep = _kernel_swi(OS_CallEvery, &r, &r);

    if (ep)
    {
        clear_ticker_and_event();
        return ep;
    }

    return NULL;
}

static void clear_ticker_and_event(void)
{
    _kernel_swi_regs r;

    _kernel_osbyte(OsByte_DisableEvent, Event_Internet, 0);

    r.r[0] = EventV;
    r.r[1] = (int)inet_entry;
    r.r[2] = (int)modules_private_word;

    _kernel_swi(OS_Release, &r, &r);

    r.r[0] = (int)timer_entry;
    r.r[1] = (int)modules_private_word;

    _kernel_swi(OS_RemoveTickerEvent, &r, &r);
}

static _kernel_oserror *mountlist_update(void)
{
    // TODO
    return NULL;
}

/* SWI server_id+0 "XXXX_OmniOp"
 *	On entry, R0 = reason code;
 *			0 = Mount
 *			1 = Dismount
 *			2 = Free
 *			3 = Enumerate servers
 *			4 = Enumerate mounts on a server
 *			5 = Enumerate active mounts
 *			6 = Open Root
 *			7 = Open User Root
 *			8 = Get Mount Info
 * 			9 = Create Print Job
 * 	       10 = Send data in Print Job
 * 	       11 = End Print Job
 * 	       12 = Abort Print Job(s)
 * 	       13 = Get Print Job Info
 *        >13 = *reserved*
 *                  Other registers as required for given reason code
 *  On exit,  Registers set as required for given reason code
 *	          All other registers preserved on exit
 *
 *  This SWI provides an entry point for the OmniClient to call
 *  individual client modules that have registered with it.
 */

/*	Reason code 0 - Mount server
 *        	On entry, R1 = ptr to Server string
 *        		  R2 = ptr to UserID string (optional)
 *        		  R3 = ptr to Password string (optional)
 *        		  R4 = ptr to Mount name string
 *        		  R5 = ptr to Mount path string (optional)
 *        		  R6 = ptr to Authentication server str (optional)
 *		On exit,  R1 = mount_id, or 0 if failed
 *
 *		Operation to mount a server (in fact a given 'mount' on a
 *		particular server).
 *		Strings are null terminated. Pointers are 0 if fields
 *		are not required for a given Client module. Strings not
 *		guaranteed by caller to be static across multiple calls.
 */
static _kernel_oserror *Op_Mount(_kernel_swi_regs *r)
{
    intptr_t server = r->r[1];
    intptr_t user = r->r[2];
    intptr_t auth = r->r[6];

    r->r[1] = 0; /* By default return failed */

    if (auth == 0 || ((char *)auth)[0] == 0) /* If there is no authentication server... */
    {
        auth = server; /* 	Use the file server to authenicate */
    }

    if (user == 0 || ((char *)user)[0] == 0) /* If there is no user specified... */
    {
        auth = 0; /* Don't authenticate */
    }

    _kernel_swi_regs rr;

    rr.r[0] = auth;
    rr.r[1] = user;
    rr.r[2] = r->r[3];

    _kernel_oserror *ep = _kernel_swi(libsmb_SetUser, &rr, &rr);

    if (ep)
    {
        return ep;
    }

    rr.r[0] = server;
    rr.r[1] = r->r[4];
    rr.r[2] = r->r[5];

    ep = _kernel_swi(libsmb_Mount, &rr, &rr);

    if (ep)
    {
        return ep;
    }

    osmb_active_mount *am = malloc(sizeof(osmb_active_mount));
    if (am == NULL)
        return message_trans_error_lookup(err_NO_MEMORY);

    char *new_name = (char *)r->r[4];

    am->magic = osmb_MOUNT_MAGIC;
    am->server_id = 0;
    am->mount_name = malloc(strlen(new_name) + 1);
    if (am->mount_name == NULL)
    {
        free(am);
        return message_trans_error_lookup(err_NO_MEMORY);
    }

    strcpy(am->mount_name, new_name);

    osmb_active_mount **app = &mount_list;

    while ((*app != 0) && (strcmp(new_name, (*app)->mount_name) > 0))
    {
        app = &((*app)->next);
    }

    am->next = *app;
    *app = am;

    r->r[1] = (int)am;

    return (NULL);
}

/*	Reason code 1 - Dismount server
 *		On entry, R1 = mount_id
 *
 *		Operation to dismount a previously mounted server (in fact a
 *		given 'mount' on a particular server).
 */
static _kernel_oserror *Op_Dismount(_kernel_swi_regs *r)
{
    osmb_active_mount *am = (osmb_active_mount *)r->r[1];
    _kernel_swi_regs rr;
    _kernel_oserror *ep;

    if (am == 0 || am->magic != osmb_MOUNT_MAGIC)
        return message_trans_error_lookup(err_BAD_MAGIC);

    rr.r[0] = 0;
    rr.r[1] = (int)am->mount_name;

    ep = _kernel_swi(libsmb_Dismount, &rr, &rr);

    return ep;
}

/*	Reason code 2 - Freespace on mount
 *		On entry, R1 = mount_id
 *		On exit,  R1 = user free space on mount (bytes)
 *		          R2 = user used space on mount (bytes)
 *		          R3 = total size of mount (bytes)
 *
 *		Returns freespace. Numbers are unsigned 32-bit integers. If
 *		any value is greater than (2^32 - 1) (=4Gbytes!) then simply
 *		return the maximum (0xFFFFFFFF).
 *              The exact interpretation of 'user freespace' and 'total
 *              size' is client dependent, however R1+R2 >= R3.
 */
static _kernel_oserror *Op_Free(_kernel_swi_regs *r)
{
    osmb_active_mount *am = (osmb_active_mount *)r->r[1];
    _kernel_swi_regs rr;
    _kernel_oserror *ep;

    if (am == 0 || am->magic != osmb_MOUNT_MAGIC)
        return message_trans_error_lookup(err_BAD_MAGIC);

    rr.r[1] = (int)am->mount_name;

    ep = _kernel_swi(NFS_FreeSpace, &rr, &rr);

    if (ep)
        return ep;

    r->r[1] = rr.r[0];
    r->r[2] = rr.r[2] - rr.r[3];
    r->r[3] = rr.r[2];

    return (NULL);
}

/*	Reason code 3 - Enumerate all servers on network
 *		On entry, R1 = ptr to buffer for servers list
 *		          R2 = size of buffer (bytes)
 *		          R3 = 0, start enumerating servers
 *		               not 0, continue enumerating servers
 *		On exit,  R1 = ptr to next free byte in buffer, word aligned
 *		          R3 = 0, operation complete
 *		               not 0, buffer full, call again with this R3
 *
 *		Operation scans visible network and returns block filled
 *		with Server records for every possible server, in the
 *		following format;
 *
 *		+0	server_id
 *		$4	shortname (no more than 24 characters, 0-terminated)
 *			fullname (no more than 64 characters, 0-terminated)
 *			description (some additional string, <= 48 chars)
 *
 *		+n	server_id
 *		$n+4	shortname/fullname/description
 *		...
 *
 *		Where n is the number of bytes, aligned upwards to a word
 *		boundary.
 *
 *		'shortname' is a short description of the server for Large
 *		and Small icon filer displays. eg, "server"
 *		'fullname' is a full description of the server for Full info
 *		filer displays. eg, "server.subnet.net"
 *              'description' is some textual field for tacking on the end
 *              of Full info filer displays. [We should discuss the sort of
 *              things that might go in here].
 *
 *		If R3 is not 0 on exit, then the enumeration is not complete
 *		(buffer full), and the reason code is called again with the
 *		new R3 value. This process continues until the enumeration
 *		is complete.
 */
static _kernel_oserror *Op_Servers(_kernel_swi_regs *r)
{
    /* libsmb doesn't support this yet */
    return message_trans_error_lookup(err_NOT_SUPPORTED);
}

/*	Reason code 4 - Enumerate all mounts on a server
 *		On entry, R1 = ptr to buffer for mounts list
 *		          R2 = size of buffer (bytes)
 *		          R3 = 0, start enumerating mounts
 *		               not 0, continue enumerating mounts
 *		          R4 = server_id
 *		On exit,  R1 = ptr to last byte written to buffer
 *		          R3 = 0, operation complete
 *		               not 0, buffer full, call again with this R3
 *
 *		Operation scans visible network and returns block filled
 *		with Mount records for every possible mount on the given
 *		server, in the following format;
 *
 *		+0	mount_id (or 0 if not connected)
 *		$4	shortname (no more than 16 characters, 0-terminated)
 *			fullname (no more than 32 characters, 0-terminated)
 *			description (some additional string, <= 64 chars)
 *
 *		+n	mount_id
 *		$n+4	shortname/fullname/description
 *		...
 *
 *		Where n is the number of bytes, aligned upwards to a word
 *		boundary.
 *
 *		'shortname' is a short description of the mount for Large
 *		and Small icon filer displays. eg, "leafdir"
 *		'fullname' is a full description of the mount for Full info
 *		filer displays. eg, "dir1.dir2.leafdir"
 *              'description' is some textual field for tacking on the end
 *              of Full info filer displays. We should discuss the sort of
 *              things that might go in here.
 *
 *		If R3 is not 0 on exit, then the enumeration is not complete
 *		(buffer full), and the reason code is called again with the
 *		new R3 value. This process continues until the enumeration
 *		is complete.
 */
static _kernel_oserror *Op_Mounts(_kernel_swi_regs *r)
{
    /* implement when libsmb module exports this functionality */
    return message_trans_error_lookup(err_NOT_SUPPORTED);
}

/*	Reason code 5 - Enumerate active (connected) mounts
 *		On entry, R1 = ptr to buffer for mounts list
 *		          R2 = size of buffer (bytes)
 *		          R3 = 0, start enumerating mounts
 *		               not 0, continue enumerating mounts
 *		On exit,  R1 = ptr to last byte written to buffer
 *		          R3 = 0, operation complete
 *		               not 0, buffer full, call again with this R3
 *
 *		Operation returns buffer filled with Mount records for every
 *		active (connected) mount on a server, in the following format;
 *
 *		+0	server_id
 *		+4	mount_id
 *		$8 	mount name (no more than 16 chars, 0-terminated)
 *
 *		+n	server_id
 *		...
 *
 *		Where n is the number of bytes, aligned upwards to a word
 *		boundary.
 *
 *		'mount name' is the mount name, as passed in the Mount
 *		(reason code = 0) OmniOp SWI call.
 *
 *		If R3 is not 0 on exit, then the enumeration is not complete
 *		(buffer full), and the reason code is called again with the
 *		new R3 value. This process continues until the enumeration
 *		is complete.
 */
static _kernel_oserror *Op_ActiveMounts(_kernel_swi_regs *r)
{
    _kernel_oserror *ep;
    osmb_active_mount *am;
    char *buffer = (char *)r->r[1];
    int remaining = r->r[2];

    if (r->r[3] == 0)
    {
        ep = mountlist_update();

        if (ep)
            return ep;
        am = mount_list;
    }
    else
    {
        am = (osmb_active_mount *)r->r[3];

        if (am->magic != osmb_MOUNT_MAGIC)
            return message_trans_error_lookup(err_BAD_MAGIC);
    }

    while ((am != 0) && (remaining > 24))
    {
        int slen;

        *((int *)buffer) = (int)am->server_id;
        buffer += 4;
        *((int *)buffer) = (int)am;
        buffer += 4;
        strncpy(buffer, am->mount_name, 15);
        buffer[15] = 0;
        slen = strlen(buffer);
        slen += 4;
        slen &= (~3);

        buffer += slen;

        remaining -= 8;
        remaining -= slen;

        am = am->next;
    }

    r->r[1] = (int)buffer;
    r->r[3] = (int)am;

    return (NULL);
}

/*	Reason code 6 - Open Root of mount
 *		On entry, R1 = mount_id
 *
 *		Trigger a Filer_OpenDir on the highest point available
 *		in mount's visible directory tree. eg, '$'
 */
static _kernel_oserror *Op_Root(_kernel_swi_regs *r)
{
    char buffer[256];
    osmb_active_mount *am = (osmb_active_mount *)r->r[1];

    if (am == 0 || am->magic != osmb_MOUNT_MAGIC)
        return message_trans_error_lookup(err_BAD_MAGIC);

    sprintf(buffer, "Filer_OpenDir SMB::%s.$", am->mount_name);

    _kernel_oscli(buffer);

    return NULL;
}

/*	Reason code 7 - Open User Root of mount
 *		On entry, R1 = mount_id
 *
 *		Trigger a Filer_OpenDir on the current user's 'home'
 *		directory, or the highest point available in mount's
 *		visible directory tree if not applicable. eg, '/homes/nas'
 *		or '$'
 */
static _kernel_oserror *Op_UserRoot(_kernel_swi_regs *r)
{
    /* For SMB this is the same as the Op above */
    return Op_Root(r);
}

/*	Reason code 8 - Get (inactive/not-connected) Mount Info
 *		On entry, R1 = mount_id (of active mount)
 *			  R2 = ptr to new Mount path string
 *		On exit,  R1 = new mount facilities flags word;
 *			       bit 0 = 1, mount does need User identifier
 *			       bit 1 = 1, mount does need Password string
 *                             bits 2..31 = *reserved* zero
 *
 *		This reason code allows for the possibility of changing
 *		authentication once a mount to a given server is made.
 *		mount_id is the existing connection to a server (possibly
 *		one of several) and the new mount name/path strings are the
 *		new mount to that server. Some clients (eg, LAN Manager)
 *		allow unauthenticated new mounts, once an authenticated
 *		mount is performed.
 */
static _kernel_oserror *Op_InactiveMountInfo(_kernel_swi_regs *r)
{
    return message_trans_error_lookup(err_NOT_SUPPORTED);
}

/*	Reason code 9 - Get (active/connected) Mount Info
 *		On entry, R1 = mount_id (of active mount)
 *		On exit,  R1 = ptr to Server string
 *       		  R2 = ptr to UserID string
 *       		  R3 = ptr to Mount name string
 *       		  R4 = ptr to Mount path string
 *       		  R5 = ptr to Authentication server string
 *
 *		Operation to get information about an active mount.
 *		Strings are null terminated. Pointers are 0 if fields
 *		are not available for a given mount. Strings do not need to
 *		be guaranteed to be static across multiple calls.
 *              The Server string (R1) should be the 'full name' as supplied
 *              by OmniOp reason code 3 (Enumerate all servers).
 */
static _kernel_oserror *Op_ActiveMountInfo(_kernel_swi_regs *r)
{
    osmb_active_mount *am = (osmb_active_mount *)r->r[1];
    _kernel_oserror *ep;
    _kernel_swi_regs rr;

    if (am == 0 || am->magic != osmb_MOUNT_MAGIC)
        return message_trans_error_lookup(err_BAD_MAGIC);

    rr.r[1] = (int)am->mount_name;

    ep = _kernel_swi(NFS_MountInfo, &rr, &rr);

    if (ep)
        return ep;

    r->r[1] = rr.r[0];
    r->r[2] = rr.r[3];
    r->r[3] = rr.r[1];
    r->r[4] = rr.r[2];
    r->r[5] = rr.r[4];

    r->r[6] = (int)am->server_id;

    return NULL;
}

/* 	Reason code 10 - Create Print Job
 * 		On entry, R1 = ptr to server name
 * 	                  R2 = ptr to printer name
 * 	                  R3 = ptr to user name, or NULL
 * 	                  R4 = ptr to password string, or NULL
 * 	                  R5 = ptr to options string, or NULL
 * 	                  R6 = size of print job (bytes), or 0 if not known
 * 		On exit,  R1 = print_id, or 0 if failed
 *
 *         	Submit a new job for network printing. The user name and
 *         	options string are optional, and may be	NULL pointers.
 */
static _kernel_oserror *Op_CreateJob(_kernel_swi_regs *r)
{
    return message_trans_error_lookup(err_NOT_SUPPORTED);
}

/* 	Reason code 11 - Send data in Print Job
 * 		On entry, R1 = print_id
 * 		          R2 = ptr to data block to send
 * 		          R3 = size of data block to send
 * 		On exit,  R3 = number of bytes not sent, or 0 for all done
 * 		All other registers preserved on exit
 *
 *         	Send a block of data down network printer stream for a given
 *         	active print_id word.
 */
static _kernel_oserror *Op_SendJob(_kernel_swi_regs *r)
{
    return message_trans_error_lookup(err_NOT_SUPPORTED);
}

/* 	Reason code 12 - End Print Job
 * 		On entry, R1 = print_id
 * 		All registers preserved on exit
 *
 *         	End a specified print job normally (ie, all data
 *         	transmitted).
 */
static _kernel_oserror *Op_EndJob(_kernel_swi_regs *r)
{
    return message_trans_error_lookup(err_NOT_SUPPORTED);
}

/* 	Reason code 13 - Abort Print Job(s)
 * 		On entry, R1 = print_id, or
 * 		             = 0, to abort all jobs
 * 		All registers preserved on exit
 *
 *         	Abort a specified print job, or all current jobs.
 */
static _kernel_oserror *Op_AbortJob(_kernel_swi_regs *r)
{
    return message_trans_error_lookup(err_NOT_SUPPORTED);
}

/* 	Reason code 14 - Get Print Job Info
 * 		On entry, R1 = print_id
 * 		On exit,  R1 = local job status word
 * 			  R2 = local job # bytes sent
 * 			  R3 = error/status block ptr, or 0
 * 			  R4 = remote job status word
 * 			  R5 = remote job # bytes printed
 * 			  R6 = error/status block ptr, or 0
 * 		All other registers preserved on exit
 *
 *         	Get information on a specified print job. The status word
 *         	(R1, R3) is defined above in SWI Omni_JobStatus.
 */
static _kernel_oserror *Op_GetJobInfo(_kernel_swi_regs *r)
{
    return message_trans_error_lookup(err_NOT_SUPPORTED);
}

/*	Reason code 15 - Clear Print Job(s)
 *		On entry, R1 = pjob_id, or
 *			     = 0, to clear all inactive jobs
 *		All registers preserved on exit
 *
 *		Clear a specified print job, or all inactive jobs. OmniClient
 *		will make this call when the print job submitter indicates,
 *		by calling SWI Omni_ClearJob, longer requires status information
 *		about that job. The status of a print job should reside in
 *		memory forever if this reason code is not called.
 *		'Inactive' in this case means either 'transfer complete' (3) or
 *		'job has terminal error' (5).
 */

static _kernel_oserror *Op_ClearJob(_kernel_swi_regs *r)
{
    return message_trans_error_lookup(err_NOT_SUPPORTED);
}

/*	Reason code 16 - Enumerate all printers on network
 *		On entry, R1 = ptr to buffer for printers list (word aligned)
 *			  R2 = size of buffer (words * 4)
 *			  R3 = 0, start enumerating printers
 *			       not 0, continue enumerating printers
 *		On exit,  R1 = ptr to next free byte in buffer, word aligned
 *			  R3 = 0, operation complete
 *			       not 0, buffer full, call again with this R3
 *
 *		Operation scans visible network and returns block filled
 *		with Printer records for every possible printer, in the
 *		following format;
 *
 *		+0	flags word (see below)
 *		$4	printer (no more than 24 chars, 0-terminated)
 *			server (no more than 64 chars, 0-terminated)
 *
 *		+n	flags
 *		$n+4	name
 *		...
 *
 *		Where n is the number of bytes, aligned upwards to a word
 *		boundary.
 */

static _kernel_oserror *Op_EnumeratePrinters(_kernel_swi_regs *r)
{
    return message_trans_error_lookup(err_NOT_SUPPORTED);
}

_kernel_oserror *osmb_OmniOP(_kernel_swi_regs *r)
{
    dprintf(("", "OmniOP reason %d\n", r->r[0]));
    switch (r->r[0])
    {
    case OmniOp_Mount:
        return Op_Mount(r);

    case OmniOp_Dismount:
        return Op_Dismount(r);

    case OmniOp_Free:
        return Op_Free(r);

    case OmniOp_EnumerateServers:
        return Op_Servers(r);

    case OmniOp_EnumerateMountsOnServer:
        return Op_Mounts(r);

    case OmniOp_EnumerateActiveMounts:
        return Op_ActiveMounts(r);

    case OmniOp_OpenRoot:
        return Op_Root(r);

    case OmniOp_OpenUserRoot:
        return Op_UserRoot(r);

    case OmniOp_GetInactiveMountInfo:
        return Op_InactiveMountInfo(r);

    case OmniOp_GetActiveMountInfo:
        return Op_ActiveMountInfo(r);

    case OmniOp_CreatePrintJob:
        return Op_CreateJob(r);

    case OmniOp_SendPrintJobData:
        return Op_SendJob(r);

    case OmniOp_EndPrintJob:
        return Op_EndJob(r);

    case OmniOp_AbortPrintJob:
        return Op_AbortJob(r);

    case OmniOp_GetPrintJobInfo:
        return Op_GetJobInfo(r);

    case OmniOp_ClearPrintJob:
        return Op_ClearJob(r);

    case OmniOp_EnumeratePrinters:
        return Op_EnumeratePrinters(r);

    default:
        return message_trans_error_lookup(err_NOT_SUPPORTED);
    }
}

_kernel_oserror *osmb_swi(int n, _kernel_swi_regs *r, void *pw)
{
    switch (n)
    {
    case 0:
        return osmb_OmniOP(r);

    default:
        return message_trans_error_lookup(err_NOT_SUPPORTED);
    }
}

void osmb_service_OmniAction_Starting()
{
    _kernel_oserror *ep;
    dprintf(("", "Registering\n"));
    ep = register_client();
    if (ep == 0)
    {
        dprintf(("", "Registration successful\n"));
        registered_with_omniclient = true;
    }
    else
    {
        dprintf(("", "Registration failed, '%s'\n", ep->errmess));
    }
}

void osmb_service_OmniAction_Died()
{
    char *module_base = (char *)Image_RO_Base;
    char *module_title = module_base + *((int *)(module_base + 0x10));
    dprintf(("", "Marking as de-registered\n"));
    registered_with_omniclient = false;
    delete_module(module_title);
}

void osmb_service_OmniAction(_kernel_swi_regs *r)
{
    dprintf(("", "Service_OmniAction... "));
    switch (r->r[0])
    {
    case Service_OmniAction_Starting:
        osmb_service_OmniAction_Starting();
        break;

    case Service_OmniAction_Died:
        osmb_service_OmniAction_Died();
        break;
    }
}

void osmb_service(int n, _kernel_swi_regs *r, void *pw)
{
    switch (n)
    {
    case Service_OmniAction:
        osmb_service_OmniAction(r);
        break;

    case Service_ResourceFSStarting:
        /* Reregister with ResourceFS */
        (*(void (*)(void *, void *, void *, void *))r->r[2])(Resources(), 0, 0, (void *)r->r[3]);
        break;
    }
}

_kernel_oserror *osmb_initialise(const char *tail, int base, void *pw)
{
    _kernel_oserror *ep;

    debug_initialise("", "OmniSMB", NULL);
    debug_set_options(0, 0, 0);
    debug_output_device(TML_OUTPUT);

    modules_private_word = pw;

    server_list = NULL;
    mount_list = NULL;
    print_list = NULL;

    registered_with_omniclient = false;

    tick_pending = datagram_pending = callback_pending = 0;

    server_list_has_changed = false;

    rpc_socket = -1; /* Give it an invalid socket number before the event is enabled */

    dprintf(("", "About to setup resources\n"));

    ep = _swix(ResourceFS_RegisterFiles, _IN(0), Resources());
    if (ep)
        return ep;

    ep = _swix(MessageTrans_OpenFile, _INR(0, 2),
               msg_struct, "Resources:$.ThirdParty.OmniClient.OmniSMB.Messages", 0);
    if (ep)
        goto msg_dereg;

    dprintf(("", "About to setup find server code\n"));

    ep = find_server_setup();
    if (ep)
        goto msg_close;

    dprintf(("", "About to setup ticker and event\n"));

    ep = setup_ticker_and_event();
    if (ep)
        goto msg_close;

    dprintf(("", "About to set callback for first request\n"));

    tick_pending = 1;
    setup_callback();

    dprintf(("", "About to IconSprite the resources\n"));

    _kernel_oscli("IconSprites Resources:$.ThirdParty.OmniClient.OmniSMB.Sprites");

    dprintf(("", "About to register as client\n"));

    if (register_client() == 0)
        registered_with_omniclient = true;

    return NULL;

msg_close:
    _swix(MessageTrans_CloseFile, _IN(0), msg_struct);
msg_dereg:
    _swix(ResourceFS_DeregisterFiles, _IN(0), Resources());
    debug_terminate();
    return ep;
}

_kernel_oserror *osmb_finalise(int fatal, int podule, void *pw)
{
    osmb_active_mount *am;
    osmb_active_server *as;
    osmb_print_job *pj;

    if (registered_with_omniclient)
    {
        deregister_client();
    }

    find_server_clear();

    clear_ticker_and_event();
    clear_callback();

    am = mount_list;
    while (am)
    {
        osmb_active_mount *am_next = am->next;
        if (am->mount_name != 0)
            free(am->mount_name);
        /* Avoid confusion should we be restarted and offered an old handle */
        am->magic = 0;
        free(am);
        am = am_next;
    }

    as = server_list;
    while (as)
    {
        osmb_active_server *as_next = as->next;
        if (as->server_name)
            free(as->server_name);
        as->magic = 0;
        free(as);
        as = as_next;
    }

    pj = print_list;
    while (pj)
    {
        osmb_print_job *pj_next = pj->next;
        if (pj->handle)
        {
            _swix(OS_Find, _INR(0, 1), OSFind_Close, pj->handle);
        }
        pj->magic = 0;
        free(pj);
        pj = pj_next;
    }

    /* Unset NFSFiler$Running variable to allow !NFSFiler to startup */
    _kernel_oscli("UnSet NFSFiler$Running");

    /* Finished with the resources now */
    _swix(MessageTrans_CloseFile, _IN(0), msg_struct);
    _swix(ResourceFS_DeregisterFiles, _IN(0), Resources());

    debug_terminate();

    return NULL;
}

static void server_item_check_name(osmb_active_server *as)
{
    char *name;

    if (!as->good_address)
    {
        name = get_name_from_dns(as->addr);

        if (name)
        {
            char *nn, *dot;

            nn = malloc(strlen(name) + 1);
            if (nn != NULL)
            {
                free(as->server_name);
                as->server_name = nn;
                strcpy(nn, name);

                dot = strchr(name, '.');
                if ((dot) && atoi(name) == 0)
                    as->short_name_len = dot - name;
                else
                    as->short_name_len = strlen(name);

                as->good_address = 1;
            }
        }
    }
}

/* Returns true if the server list is altered */
int server_list_insert(unsigned long addr)
{
    osmb_active_server **app = &server_list;
    osmb_active_server *as;
    int changed = 0;
    unsigned int now;

    dprintf(("", "Inserting server 0x%x\n", (int)addr));

    _swix(OS_ReadMonotonicTime, _OUT(0), &now);

    while (*app)
    {
        as = *app;

        dprintf(("", "app = %p, *app = %p\n", app, *app));

        if (as->addr == addr)
        {
            as->server_ill = 0;
            as->last_seen = now;
            dprintf(("", "Address hit\n"));
            return 0;
        }
        app = &(as->next);
    }

    /* We didn't find the server so we better add it in */
    as = malloc(sizeof(osmb_active_server));
    /* If the malloc fails we ignore it this server for the moment; hopefully better luck next time */
    if (as != NULL)
    {
        char *name;

        dprintf(("", "Building new item\n"));

        name = get_name_from_dns(addr);

        as->magic = osmb_SERVER_MAGIC;
        as->addr = addr;
        as->last_seen = now;
        as->server_ill = 0;
        as->server_name = 0;

        name = get_name_from_dns(addr);
        if (name)
        {
            as->good_address = 1;
        }
        else
        {
            name = get_name_from_addr(addr);
            as->good_address = 0;
        }

        if (name)
        {
            as->server_name = malloc(strlen(name) + 1);
            if (as->server_name != NULL)
            {
                char *dot;

                strcpy(as->server_name, name);

                dot = strchr(as->server_name, '.');
                if (dot && atoi(name) == 0)
                    as->short_name_len = dot - as->server_name;
                else
                    as->short_name_len = strlen(as->server_name);
            }
        }

        if (as->server_name == 0)
        {
            as->server_name = "<No memory>";
            as->short_name_len = 11;
        }

        dprintf(("", "Built new server item at %p\n", as));

        as->next = server_list;
        server_list = as;
        changed = 1;
    }
    else
    {
        dprintf(("", "No memory for new server item\n"));
    }

    if (changed)
        server_list_has_changed = true;

    return changed;
}

/* Returns true if the server list is altered */
int server_list_purge(void)
{
    osmb_active_server **app = &server_list;
    int changed = 0;
    unsigned int now;

    _swix(OS_ReadMonotonicTime, _OUT(0), &now);

    while (*app)
    {
        osmb_active_server *as = *app;

        /* Test to see if the server is ill first so that we correctly flag the list as changed */
        if (((now - as->last_seen) > SERVER_TIMEOUT_ILL) && (as->server_ill == 0))
        {
            as->server_ill = 1;
            changed = 1;
        }

        if ((now - as->last_seen) > SERVER_TIMEOUT_DEAD)
        {
            *app = as->next;
            if (as->server_name != 0)
                free(as->server_name);
            as->magic = 0;
            free(as);

            /* Since *app is changed we don't want to move on */
            continue;
        }

        app = &(as->next);
    }

    if (changed)
        server_list_has_changed = true;

    return changed;
}

int inet_handler(_kernel_swi_regs *r, void *pw)
{
    int rc = DONT_CLAIM_EVENT;

    /* Don't need to check event number because the Inernet Event is
     * the only one we claim, and since it's specified in the CMHG header,
     * CMHG will generate appropriate filtering code for us.
     */

    _kernel_irqs_on();

    switch (r->r[1])
    {
    case Event_Internet_SocketAsync:
    case Event_Internet_SocketUrgent:
    case Event_Internet_SocketBroken:
        if (r->r[2] == rpc_socket)
        {
            datagram_pending = 1;
            setup_callback();
            rc = CLAIM_EVENT;
        }
        break;

    default:
        break;
    }

    _kernel_irqs_off();

    return rc;
}

_kernel_oserror *timer_handler(_kernel_swi_regs *r, void *pw)
{
    tick_pending = 1;
    setup_callback();

    return NULL;
}

_kernel_oserror *callback_handler(_kernel_swi_regs *r, void *pw)
{
    callback_pending = 0;

    if (datagram_pending)
    {
        datagram_pending = 0;

        /* Handle incoming data */

        dprintf(("", "About to deal with incoming data\n"));

        find_server_data();
    }

    if (tick_pending)
    {
        tick_pending = 0;

        dprintf(("", "Purging list... "));
        server_list_purge();
        /* Send out another broadcast */
        dprintf(("", "Sending RPC request\n"));

        find_server_send();
    }

    if (server_list_has_changed)
    {
        _kernel_swi_regs rr;

        server_list_has_changed = false;

        rr.r[0] = OmniSMB_OmniOp;
        rr.r[1] = 0;

        _kernel_swi(Omni_EnumerateMounts, &rr, &rr);
    }

    return NULL;
}
